<title>Aime - 研发场景最佳实践</title>
<url>https://bytedance.larkoffice.com/wiki/UKfTwFL34iLb0WkgVg9cRbg7nSe</url>
<content>
最近更新：2026-01-09

## 背景与目标
Aime 是专为字节同学打造的 AI Agent 工作平台，它深度集成了内部工具与研发知识，旨在帮助我们从繁琐、重复的任务中解放出来，更专注于高价值的创造性工作。

这份指南将作为一份“活的文档”，持续为你提供可落地的“写代码”最佳实践。无论你是想修复一个紧急的线上 Bug、完成一个常规的需求迭代，还是对老旧模块进行重构，都能在这里找到稳健、高效的 Aime 使用姿势。

**我们的目标是：**

- **统一共识**：明确 Aime 在研发流程中的定位，知道“何时用、怎么用、用到什么程度”。

- **降低门槛**：提供可直接套用的指令模板与正反案例，让你在日常工作中“开箱即用”。

- **提升价值**：真正将 Aime 作为一名可并行的“代码协作助手”，稳步提升研发效率与代码质量。

**适用人群：**

- **研发工程师**：希望减少重复编码，加速需求交付和技术改造。

- **代码评审同学 (Reviewer)**：关心 Aime 生成代码的质量与合规性。

- **测试与 CI 维护同学**：需要理解 Aime 如何与自动化测试及发布流程集成。

## 核心理念与边界
要充分发挥 Aime 的价值，首先需要理解它与传统 AI 助手的核心区别，并遵循一些基本原则。

### Aime：可并行的异步工程师
与传统的 IDE 插件或聊天式 AI 助手不同，Aime 的工作模式更像一个独立的“远程智能代理”（Agent）。

- **传统 AI 助手**：你在本地编码，AI 在一旁实时问答。你需要全程监督，手动拆分任务，上下文切换成本高。

- **Aime Agent**：你只需下达一次明确的指令，Aime 就会在一个隔离、安全的环境中启动一个独立的任务。它能**自主完成从克隆仓库、理解代码、编写实现、运行测试到提交 MR 的全过程**，真正做到异步并行。

你可以同时启动多个 Aime 任务，分别处理不同的需求或修复，彼此互不干扰。它不再是一个需要你“手把手教”的工具，而是一个能**独立交付、分担负荷的“工程伙伴”**。

![board_CRBJwmqtJhry6ybsHy4cvP5fnCf](board_CRBJwmqtJhry6ybsHy4cvP5fnCf.drawio)

### 核心价值：不止于“快”
将 Aime 融入研发流程，能带来多维度的价值：

- **专注高价值工作**：将接口封装、单元测试、脚手架搭建等规则明确的任务交给 Aime，让你能聚焦于架构设计、复杂问题攻坚等创造性环节。

- **清理技术债**：文档补全、类型标注、依赖升级、代码规范化等“低优先级”任务，往往是技术债的重灾区。Aime 可以持续、异步地清理这些积压项，稳步提升代码库健康度。

- **补充“弹性人力”**：面对人手短缺，很多有价值但非紧急的项目（如老系统重构、性能优化、观测性建设）常常被搁置。Aime 可以作为一支可随时扩容的工程小队，让这些项目得以启动和推进。

- **加速项目启动**：让 Aime 完成初始化仓库、生成项目脚手架、配置 CI/CD 等“打地基”的工作。你接手时，可以直接进入核心业务逻辑的实现。

### 使用原则：小步快跑，明确可控
为了确保 Aime 的产出稳定、可靠，我们强烈建议遵循以下原则：

- **小步快跑，增量提交**：倾向于将任务拆解成小块，让 Aime 生成小而美的 Merge Request。这不仅便于你快速审查（Review），也更容易验证改动的正确性。

- **明确上下文，消除歧义**：Aime 的表现上限，取决于你提供信息的质量。指令越清晰、上下文越完备，产出就越精准。

- **低风险路径优先**：优先将 Aime 用于那些有明确规范、有参考示例、易于验证的场景。对于探索性的、无先例可循的复杂任务，建议先由人来完成核心设计。

## 通用工作流与指令框架
“Garbage in, garbage out.” 这句话在与 Aime 协作时体现得淋漓尽致。一个高质量的指令，是获得生产级代码的基石。我们推荐使用以下框架来组织你的需求，确保 Aime 能准确理解并高效执行。

<callout icon="bulb" bgc="4" bc="4">
**核心思想**：把 Aime 当作一个聪明但对项目背景一无所知的新同事。你需要清晰地告诉他：**在哪里（Where）**、**做什么（What）**、**怎么做（How）**，以及**如何算做好（Acceptance Criteria）**。
</callout>

### 1. 从哪开始 (Where)：提供关键起点
在动手之前，你自己会先打开哪个仓库、哪个文件，或查阅哪篇文档？请把这些“起点”信息直接告诉 Aime。

- **代码库与分支**：明确告知 Aime 需要操作的 **Git 仓库地址**和**目标分支**。使用 `@仓库` 快捷指令可以精准选择。

- **关键文件与模块**：指出与任务直接相关的**文件路径**或**核心目录**。例如：“改动主要集中在 `src/modules/user/service.ts` 文件中。”

- **相关文档与资源**：附上相关的 **PRD**、**技术设计文档**、**API 规范**或**错误日志**的链接。

### 2. 做什么 (What)：定义清晰的目标
避免使用模糊的词语，用可执行的语言描述任务目标。

- **差指令**：“帮我优化一下性能。”

- **好指令**：“优化 `/api/v1/list_items` 接口的响应时间。目标是将 P95 延迟从 500ms 降低到 200ms 以内。”

### 3. 怎么做 (How)：给出实现路径与参考
对于非trivial的任务，直接给出你倾向的实现思路或步骤，能极大地提升 Aime 的成功率和代码质量。

- **分解步骤**：将一个复杂功能拆解成清晰的步骤。
	- **示例**：“1. 在 `user.thrift` 中为 `User` 结构体添加 `age` 字段；2. 运行 `make idl` 生成代码；3. 在 `user_service.go` 的 `CreateUser` 方法中支持 `age` 参数的写入。”

- **提供参考范例 (Code Snippet)**：分享一段符合预期的代码片段或函数实现，Aime 会智能地模仿其风格和模式。
	- **示例**：“请参考 `UpdateUser` 函数的错误处理逻辑，对新写的 `DeleteUser` 函数进行改造。”

- **践行“防御性指令”**：预判 Aime 可能“踩坑”的地方，并提前给出提示。
	- **示例**：“**注意**：修改完配置后，**必须**调用 `Cache.clear_all()` 方法来清理缓存，否则在测试环境中无法立即看到效果。”

### 4. 验收标准与交付 (Acceptance & Delivery)
明确告知 Aime “完成”的定义，并指定你希望的交付形式。

- **工程规范**：要求 Aime 遵循特定的代码风格、静态检查和测试标准。
	- **示例**：“所有公开函数都必须添加符合 JSDoc 规范的注释。” “提交前需确保 `go lint` 和 `go test ./...` 全部通过。”

- **验收场景**：定义需要覆盖的测试用例，特别是边界情况。
	- **示例**：”为新接口添加单元测试，必须覆盖‘用户不存在’和‘数据库连接失败’这两种场景，并 Mock 掉 Redis 依赖。“

- **交付方式**：明确你希望 Aime 最终产出什么。
	- **示例**：“完成代码编写和测试后，请创建一个 Merge Request 到 `master` 分支，并附上本次改动的功能说明。” 或 “请将重构方案总结成一份 Markdown 文档。”

---

通过这套“Where-What-How-Acceptance”的框架，你可以将一个模糊的想法，转化为一个 Aime 可以精确执行的、高质量的开发任务。

## 指令模板与正反例
为了让你能更直观地感受到“好指令”与“坏指令”的区别，我们提供了一系列可直接套用的模板和正反案例。

### 正向指令模板 (Good Cases)
#### 场景一：修复线上 Bug
> **背景**：当人力紧张时，一个紧急的线上 Panic 需要处理。这是 Aime 发挥“弹性人力”价值的典型场景。
> 
> **模板链接**：[修复线上 Panic](https://aime.bytedance.net/chat?autoreg=true&share_id=7011a7b0-c9ed-468c-b274-45c51ec01b29)
> 

<callout icon="point_up" bgc="4" bc="4">
帮我修复一个线上 Panic：在 `GetHomepageData` 接口中，如果用户没有 `widgets` 数据，会引发空指针解引用。
1. **【关键上下文】** 这是相关的 Panic 堆栈日志：`[... paste log here ...]`
2. **【实现路径】** 定位到 `homepage_service.go` 文件中的问题代码，并在访问 `widgets` 前添加一个**空指针检查**。
3. **【验收标准】** 补齐单元测试，确保当 `widgets` 为 nil 时接口能正常返回，不再 panic。
4. **【交付方式】** 在 `bugfix/fix-homepage-panic` 分支上提交你的改动，并创建一个 MR 到 `develop` 分支。
</callout>

#### 场景二：开发后端新 API
> **背景**：为现有服务添加一个功能类似的 API，这类有明确参考、实现路径清晰的任务非常适合交给 Aime。
> 
> **模板链接**：[添加后端新接口](https://aime.bytedance.net/share/eb7c5849-7a15-42c5-ab1a-d73b032f4c22)
> 

<callout icon="v" bgc="4" bc="4">
帮我为用户服务添加一个获取用户配置（`UserProfile`）的新接口。
1. **【从哪开始】** 你需要先在 `api/idl/user.thrift` 中添加一个 `GetUserProfile(request)` 方法，然后在 `service/user_service.go` 中实现它。
2. **【实现路径】** 修改 `thrift` 文件后，**必须先运行&nbsp;kitex user_service.thrift** 来生成最新的代码。`user_service.go` 中的 `GetAccountInfo` 方法是你的参考范例，请遵循它的错误处理和 DTO 转换逻辑。
3. **【验收标准】** 你需要为 `GetUserProfile` 添加新的单元测试（Mock 掉 `DAO` 层调用），并确保 `go lint` 和 `go test` 全部通过。
4. **【防御性指令】** 注意，项目中使用的 kitex 版本是 v0.5.0，请勿使用最新版本，以免产生兼容性问题。
</callout>

#### 场景三：开发前端组件功能
> **背景**：为现有组件添加一个交互功能，例如“复制到剪贴板”。这类任务涉及具体的 UI 交互和内部工具库的使用。
> 

<callout icon="ok_hand" bgc="4" bc="4">
请在 `src/components/ApiTokenCard.vue` 组件里，为 token 字符串添加一个‘复制到剪贴板’的功能。
1. **【实现路径】** 在 token 字符串旁边添加一个图标按钮（icon-only button）。图标请使用我们内部组件库 `@arco-design/web-vue/es/icon` 里的 `IconCopy`。
2. **【参考范例】** 你**必须**使用 `src/composables/useClipboard.js` 中已有的 `useClipboard` 组合式函数来实现复制逻辑，**不要**自己手写 `document.execCommand`。
3. **【验收标准】** 复制成功后，按钮需要弹出一个 ‘已复制!’ 的 Tooltip 提示，持续 2 秒后自动消失。同时，确保新按钮的样式和卡片上其他图标按钮的风格完全一致。提交前 `npm run lint` 必须通过。
</callout>

#### 场景四：从零启动一个新项目
> **背景**：快速搭建一个符合基本要求的微服务脚手架，以便立即开始核心业务逻辑的开发。
> 
> **模板链接**：[快速搭建 FastAPI 服务](https://aime.bytedance.net/share/6081b0b4-96e6-4ae4-b3f8-d636047ddd54)
> 

<callout icon="raised_hand_with_fingers_splayed" bgc="4" bc="4">
帮我用 Python 快速搭建一个‘意图识别’的 API 服务脚手架。
1. **【实现路径】**
	- 使用 **FastAPI** 框架。
	- 项目应包含 `main.py` 和 `requirements.txt` (其中必须包含 `fastapi` 和 `uvicorn`)。
	- `main.py` 中**必须**包含一个 `POST /intent` 接口，其输入和输出均为 JSON 格式，包含一个 `text` 字段。
	- 在 `main.py` 里留一个**空的**、**带注释**的 `load_intent_model` 函数，并让 `/intent` 接口调用它。
2. **【验收标准】**
	- 最终我应该能直接在项目根目录运行 `uvicorn main:app --reload` 启动服务。
	- 能通过 `curl -X POST -H "Content-Type: application/json" -d '{"text": "hello"}' http://127.0.0.1:8000/intent` 调通接口并收到成功的响应。
</callout>

### 反向案例剖析 (Bad Cases)
以下是典型的“会让 Aime 蒙圈”的指令，它们往往因为缺乏上下文、标准模糊而导致产出不可用。

<grid cols="2">
<column width="50">
  #### ❌ 让 Aime 猜你的意图
  **指令**：“帮我看看这个服务。”
  **问题**：Aime 无法通灵 👻。它不知道“看”是指检查性能、分析日志、还是审查代码。这会迫使它在多个可能性中随机猜测，浪费执行时间。
</column>
<column width="50">
  #### ❌ 指令过于简短，缺乏上下文
  **指令**：“修复这个 Bug。” 或 “给我写个单测。”
  **问题**：哪个 Bug？复现路径是什么？报错信息在哪？为哪个函数写单测？需要覆盖哪些场景？缺少具体的目标和范围，Aime 根本无法开始规划任务。
</column>
</grid>

<grid cols="2">
<column width="50">
  #### ❌ 假设 Aime 知道历史上下文
  **指令**：“给刚才那个函数加个缓存。”
  **问题**：Aime 的每个任务都是近乎无状态的。如果会话中断或过长，它可能已经忘记“刚才那个函数”是哪个。**请在每一轮指令中都提供完整的上下文**。
</column>
<column width="50">
  #### ❌ 要求模糊，标准主观
  **指令**：“让这段代码更‘健壮’一点。”
  **问题**：AI 无法理解“好”、“合格”、“健壮”这类主观标准。“健壮”是指更完善的错误处理、输入校验，还是更可靠的重试机制？请将其转化为可执行、可衡量的验收标准。
</column>
</grid>

## 典型落地场景清单
基于团队的实践，我们梳理了以下一系列已被验证行之有效的 Aime 应用场景。你可以将这些场景作为“灵感库”，在日常工作中寻找可以交给 Aime 的任务。

<callout icon="star" bgc="15" bc="7">
**小提示**：这些场景卡片中的链接指向了真实的 Aime 任务分享，是学习高质量指令的绝佳材料。
</callout>

#### 需求开发与迭代
- **业务代码仿写**：根据已有模块的代码风格，快速创建新的 CRUD 接口。

- **细粒度功能实现**：完成一个独立的、逻辑清晰的函数或方法。

- **SDK/框架配置与升级**：如调整服务配置、升级 Go-SDK 版本等。

- **从 PRD/设计稿到代码**：提供清晰的文档，让 Aime 完成从需求到技术方案，再到代码的端到端实现。

#### 代码重构与迁移
- **批量代码/文案替换**：在整个项目中，安全地替换某个函数调用、常量或 UI 文案。

- **存量代码优化**：例如，将硬编码的默认值参数化，或对某个模块进行组件化拆分。

- **代码语言翻译**：例如，将一个 Python 实现的算法逻辑，用 Go 语言重写。

#### 质量保障与修复
- **CR Comment 修复**：将 Code Review 中指出的具体问题，直接丢给 Aime 来修复。

- **Bug 定位与修复**：提供详细的复现路径和错误日志，让 Aime 定位并修复业务逻辑 Bug。

- **CI/CD 问题修复**：修复流水线中的脚本错误。

- **单元测试生成与覆盖率提升**：为指定的函数或模块生成单元测试，或批量提升 MR 的测试覆盖率。

## 质量保障与合规注意
将 Aime 引入生产环境，代码质量与合规性是不可逾越的红线。以下是一些关键的最佳实践。

- **代码风格与静态分析**：在指令的“验收标准”部分，明确要求 Aime 运行项目已有的 `lint` 和静态分析工具，并修复所有问题。Aime 能够理解并执行这些命令。

- **单元测试**：始终要求 Aime 为其创建或修改的核心逻辑编写单元测试。这不仅是验证其工作质量的最佳方式，也是 Aime 进行“自我修正”的关键输入。

- **密钥与权限**：**绝对不要**在你的指令中粘贴任何形式的密钥、Token 或个人身份凭证。Aime 的工作环境已通过你的身份打通了必要的内部系统权限，无需手动提供凭证。

- **MR 规范**：在指令中明确要求 Aime 按照团队规范撰写 MR 的标题和描述。一个好的 MR 描述能极大提升代码评审的效率。

- **兼容性与回滚**：对于涉及数据库表结构变更、API 接口签名修改等重大改动，应在指令中明确提出“向后兼容”的要求，并思考潜在的回滚方案。

- **最终把关**：Aime 是你的助手，而不是你的替代。**你永远是代码质量的最终负责人**。在合并 Aime 生成的 MR 之前，请务必进行仔细的 Code Review，就像对待任何一位团队成员的提交一样。

## FAQ
**Q1: Aime 无法克隆我的代码仓库，提示没有权限？**

**A:** Aime 使用的是**你的个人身份**来执行 Git 操作。如果你本人没有某个仓库的读取权限，Aime 也同样无法访问。请先确保你拥有目标仓库至少是“Reporter”或以上的权限。同理，如果你希望 Aime 帮你创建 MR，你需要拥有“Developer”或以上的权限。

**Q2: Aime 完成了编码，但为什么没有自动创建 MR？**

**A:** 为了避免在任务未完全达到你预期时产生不必要的 MR 干扰，Aime 的默认行为是只推送代码到新分支，而不主动创建 MR。你需要在指令的“交付方式”部分明确指示它：“**请为我创建一个 Merge Request**”。你也可以在它完成编码后，在多轮对话中补充这一指令。

**Q3: Aime 生成的代码不可用或不符合预期，我该怎么办？**

**A:** 首先，尝试在当前任务中通过**多轮对话**来修正它。你可以指出具体的问题，并提供更明确的上下文或参考代码，引导 Aime 进行修复。如果多次尝试后结果仍不理想，欢迎随时在我们的官方支持渠道中反馈，并附上任务分享链接，我们的工程师会协助排查。

你也可以随时“接管” Aime 的工作环境。通过 **WebIDE** 或 **Remote-SSH** 连接到 Aime 的工作空间，你可以像在本地一样，直接修改代码、运行测试，完成最后的收尾工作。详情请参考：[Aime Remote-SSH 使用手册](https://bytedance.larkoffice.com/wiki/HSUJwrk3tiTHfLkny72c3AIrn5g)。

**Q4: 如何在 Aime 中进行研发自测？**

**A:** Aime 提供了强大的云端自测能力。你可以在任务环境中进行**快速编译、一键部署到测试环境、接口测试、甚至前端页面预览**，形成一个完整的“开发-自测”闭环。详情请参考：[Aime 研发自测功能介绍](https://bytedance.larkoffice.com/wiki/P1OZwbOZii5fw7kGVVZcCjv7ngj)。

---

## 欢迎反馈
本指南致力于成为一份与时俱进的“活文档”。如果你有任何疑问、建议，或发现了新的 Aime 提效技巧，欢迎随时联系我们，或在 Aime 用户反馈群中与我们交流。

@(zikang.zheng@bytedance.com) @(wangliuyang.520@bytedance.com) @(hanxin.hx@bytedance.com)


</content>
